"use strict";
/*
 * Inspired by Execa
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useExec = void 0;
const node_child_process_1 = __importDefault(require("node:child_process"));
const node_buffer_1 = require("node:buffer");
const node_stream_1 = __importDefault(require("node:stream"));
const node_util_1 = require("node:util");
const react_1 = require("react");
const signal_exit_1 = __importDefault(require("signal-exit"));
const useDeepMemo_1 = require("./useDeepMemo");
const useCachedPromise_1 = require("./useCachedPromise");
const useLatest_1 = require("./useLatest");
const SPACES_REGEXP = / +/g;
function parseCommand(command, args) {
    if (args) {
        return [command, ...args];
    }
    const tokens = [];
    for (const token of command.trim().split(SPACES_REGEXP)) {
        // Allow spaces to be escaped by a backslash if not meant as a delimiter
        const previousToken = tokens[tokens.length - 1];
        if (previousToken && previousToken.endsWith("\\")) {
            // Merge previous token with current one
            tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
        }
        else {
            tokens.push(token);
        }
    }
    return tokens;
}
function getSpawnedPromise(spawned) {
    return new Promise((resolve, reject) => {
        spawned.on("exit", (exitCode, signal) => {
            resolve({ exitCode, signal, timedOut: false });
        });
        spawned.on("error", (error) => {
            reject(error);
        });
        if (spawned.stdin) {
            spawned.stdin.on("error", (error) => {
                reject(error);
            });
        }
    });
}
function setupTimeout(spawned, { timeout }, spawnedPromise) {
    if (timeout === 0 || timeout === undefined) {
        return spawnedPromise;
    }
    let timeoutId;
    const timeoutPromise = new Promise((_resolve, reject) => {
        timeoutId = setTimeout(() => {
            spawned.kill("SIGTERM");
            reject(Object.assign(new Error("Timed out"), { timedOut: true, signal: "SIGTERM" }));
        }, timeout);
    });
    const safeSpawnedPromise = spawnedPromise.finally(() => {
        clearTimeout(timeoutId);
    });
    return Promise.race([timeoutPromise, safeSpawnedPromise]);
}
function setExitHandler(spawned, timedPromise) {
    const removeExitHandler = (0, signal_exit_1.default)(() => {
        spawned.kill();
    });
    return timedPromise.finally(() => {
        removeExitHandler();
    });
}
class MaxBufferError extends Error {
    constructor() {
        super("The output is too big");
        this.name = "MaxBufferError";
    }
}
const streamPipelinePromisified = (0, node_util_1.promisify)(node_stream_1.default.pipeline);
function bufferStream(options) {
    const { encoding } = options;
    const isBuffer = encoding === "buffer";
    // @ts-expect-error missing the methods we are adding below
    const stream = new node_stream_1.default.PassThrough({ objectMode: false });
    if (encoding && encoding !== "buffer") {
        stream.setEncoding(encoding);
    }
    let length = 0;
    const chunks = [];
    stream.on("data", (chunk) => {
        chunks.push(chunk);
        length += chunk.length;
    });
    stream.getBufferedValue = () => {
        return (isBuffer ? Buffer.concat(chunks, length) : chunks.join(""));
    };
    stream.getBufferedLength = () => length;
    return stream;
}
async function getStream(inputStream, options) {
    const stream = bufferStream(options);
    await new Promise((resolve, reject) => {
        const rejectPromise = (error) => {
            // Don't retrieve an oversized buffer.
            if (error && stream.getBufferedLength() <= node_buffer_1.constants.MAX_LENGTH) {
                error.bufferedData = stream.getBufferedValue();
            }
            reject(error);
        };
        (async () => {
            try {
                await streamPipelinePromisified(inputStream, stream);
                resolve();
            }
            catch (error) {
                rejectPromise(error);
            }
        })();
        stream.on("data", () => {
            // 80mb
            if (stream.getBufferedLength() > 1000 * 1000 * 80) {
                rejectPromise(new MaxBufferError());
            }
        });
    });
    return stream.getBufferedValue();
}
// On failure, `result.stdout|stderr` should contain the currently buffered stream
async function getBufferedData(stream, streamPromise) {
    stream.destroy();
    try {
        return await streamPromise;
    }
    catch (error) {
        return error.bufferedData;
    }
}
async function getSpawnedResult({ stdout, stderr }, { encoding }, processDone) {
    const stdoutPromise = getStream(stdout, { encoding });
    const stderrPromise = getStream(stderr, { encoding });
    try {
        return await Promise.all([processDone, stdoutPromise, stderrPromise]);
    }
    catch (error) {
        return Promise.all([
            {
                error: error,
                exitCode: null,
                signal: error.signal,
                timedOut: error.timedOut || false,
            },
            getBufferedData(stdout, stdoutPromise),
            getBufferedData(stderr, stderrPromise),
        ]);
    }
}
function stripFinalNewline(input) {
    const LF = typeof input === "string" ? "\n" : "\n".charCodeAt(0);
    const CR = typeof input === "string" ? "\r" : "\r".charCodeAt(0);
    if (input[input.length - 1] === LF) {
        // @ts-expect-error we are doing some nasty stuff here
        input = input.slice(0, -1);
    }
    if (input[input.length - 1] === CR) {
        // @ts-expect-error we are doing some nasty stuff here
        input = input.slice(0, -1);
    }
    return input;
}
function handleOutput(options, value) {
    if (options.stripFinalNewline) {
        return stripFinalNewline(value);
    }
    return value;
}
const getErrorPrefix = ({ timedOut, timeout, signal, exitCode, }) => {
    if (timedOut) {
        return `timed out after ${timeout} milliseconds`;
    }
    if (signal !== undefined) {
        return `was killed with ${signal}`;
    }
    if (exitCode !== undefined) {
        return `failed with exit code ${exitCode}`;
    }
    return "failed";
};
const makeError = ({ stdout, stderr, error, signal, exitCode, command, timedOut, options, }) => {
    const prefix = getErrorPrefix({ timedOut, timeout: options?.timeout, signal, exitCode });
    const execaMessage = `Command ${prefix}: ${command}`;
    const shortMessage = error ? `${execaMessage}\n${error.message}` : execaMessage;
    const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
    if (error) {
        // @ts-expect-error not on Error
        error.originalMessage = error.message;
        error.message = message;
    }
    else {
        error = new Error(message);
    }
    // @ts-expect-error not on Error
    error.shortMessage = shortMessage;
    // @ts-expect-error not on Error
    error.command = command;
    // @ts-expect-error not on Error
    error.exitCode = exitCode;
    // @ts-expect-error not on Error
    error.signal = signal;
    // @ts-expect-error not on Error
    error.stdout = stdout;
    // @ts-expect-error not on Error
    error.stderr = stderr;
    if ("bufferedData" in error) {
        delete error["bufferedData"];
    }
    return error;
};
function defaultParsing({ stdout, stderr, error, exitCode, signal, timedOut, command, options, }) {
    if (error || exitCode !== 0 || signal !== null) {
        const returnedError = makeError({
            error,
            exitCode,
            signal,
            stdout,
            stderr,
            command,
            timedOut,
            options,
        });
        throw returnedError;
    }
    return stdout;
}
function useExec(command, optionsOrArgs, options) {
    const { parseOutput, input, onData, onWillExecute, initialData, execute, keepPreviousData, onError, ...execOptions } = Array.isArray(optionsOrArgs) ? options || {} : optionsOrArgs || {};
    const useCachedPromiseOptions = {
        initialData,
        execute,
        keepPreviousData,
        onError,
        onData,
        onWillExecute,
    };
    const args = (0, useDeepMemo_1.useDeepMemo)([
        Array.isArray(optionsOrArgs) ? optionsOrArgs : [],
        execOptions,
        input,
    ]);
    const abortable = (0, react_1.useRef)();
    const parseOutputRef = (0, useLatest_1.useLatest)(parseOutput || defaultParsing);
    const fn = (0, react_1.useCallback)(async (_command, _args, _options, input) => {
        const [file, ...args] = parseCommand(_command, _args);
        const command = [file, ...args].join(" ");
        const options = {
            stripFinalNewline: true,
            ..._options,
            signal: abortable.current?.signal,
            encoding: _options?.encoding === null ? "buffer" : _options?.encoding || "utf8",
            env: { ...process.env, ..._options?.env },
        };
        const spawned = node_child_process_1.default.spawn(file, args, options);
        const spawnedPromise = getSpawnedPromise(spawned);
        const timedPromise = setupTimeout(spawned, options, spawnedPromise);
        const processDone = setExitHandler(spawned, timedPromise);
        if (input) {
            spawned.stdin.end(input);
        }
        const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult] = await getSpawnedResult(spawned, options, processDone);
        const stdout = handleOutput(options, stdoutResult);
        const stderr = handleOutput(options, stderrResult);
        return parseOutputRef.current({
            // @ts-expect-error too many generics, I give up
            stdout,
            // @ts-expect-error too many generics, I give up
            stderr,
            error,
            exitCode,
            signal,
            timedOut,
            command,
            options,
        });
    }, [parseOutputRef]);
    return (0, useCachedPromise_1.useCachedPromise)(fn, [command, ...args], {
        ...useCachedPromiseOptions,
        abortable,
    });
}
exports.useExec = useExec;
