"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useFetch = void 0;
const react_1 = require("react");
const media_typer_1 = __importDefault(require("media-typer"));
const content_type_1 = __importDefault(require("content-type"));
const useDeepMemo_1 = require("./useDeepMemo");
const useCachedPromise_1 = require("./useCachedPromise");
const useLatest_1 = require("./useLatest");
const { emitWarning } = process;
// to remove when we switch to Node 18
process.emitWarning = (warning, ...args) => {
    if (args[0] === "ExperimentalWarning") {
        return;
    }
    if (args[0] && typeof args[0] === "object" && args[0].type === "ExperimentalWarning") {
        return;
    }
    // @ts-expect-error too many different types but it's ok since we pass what was passed
    return emitWarning(warning, ...args);
};
const undici_1 = require("undici");
function isJSON(contentTypeHeader) {
    if (contentTypeHeader) {
        const ct = content_type_1.default.parse(contentTypeHeader);
        const mediaType = media_typer_1.default.parse(ct.type);
        if (mediaType.subtype === "json") {
            return true;
        }
        if (mediaType.suffix === "json") {
            return true;
        }
        if (mediaType.suffix && /\bjson\b/i.test(mediaType.suffix)) {
            return true;
        }
        if (mediaType.subtype && /\bjson\b/i.test(mediaType.subtype)) {
            return true;
        }
    }
    return false;
}
async function defaultParsing(response) {
    if (!response.ok) {
        throw new Error(response.statusText);
    }
    const contentTypeHeader = response.headers.get("content-type");
    if (contentTypeHeader && isJSON(contentTypeHeader)) {
        return await response.json();
    }
    return await response.text();
}
/**
 * Fetch the URL and returns the {@link AsyncState} corresponding to the execution of the fetch. The last value will be kept between command runs.
 *
 * @example
 * ```
 * import { useFetch } from '@raycast/utils';
 *
 * const Demo = () => {
 *   const { isLoading, data, revalidate } = useFetch('https://api.example');
 *
 *   return (
 *     <Detail
 *       isLoading={isLoading}
 *       markdown={data}
 *       actions={
 *         <ActionPanel>
 *           <Action title="Reload" onAction={() => revalidate()} />
 *         </ActionPanel>
 *       }
 *     />
 *   );
 * };
 * ```
 */
function useFetch(url, options) {
    const { parseResponse, initialData, execute, keepPreviousData, onError, onData, onWillExecute, ...fetchOptions } = options || {};
    const useCachedPromiseOptions = {
        initialData,
        execute,
        keepPreviousData,
        onError,
        onData,
        onWillExecute,
    };
    const parseResponseRef = (0, useLatest_1.useLatest)(parseResponse || defaultParsing);
    const abortable = (0, react_1.useRef)();
    const fn = (0, react_1.useCallback)(async (url, options) => {
        const res = await (0, undici_1.fetch)(url, { signal: abortable.current?.signal, ...options });
        return (await parseResponseRef.current(res));
    }, [parseResponseRef]);
    const args = (0, useDeepMemo_1.useDeepMemo)([url, fetchOptions]);
    return (0, useCachedPromise_1.useCachedPromise)(fn, args, { ...useCachedPromiseOptions, abortable });
}
exports.useFetch = useFetch;
